$date
	Wed Dec 17 00:18:34 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ns
$end
$scope module mips_cpu_tb $end
$var wire 32 ! pc_out [31:0] $end
$var wire 32 " alu_result [31:0] $end
$var reg 1 # clk $end
$var reg 1 $ reset $end
$scope module uut $end
$var wire 32 % alu_result [31:0] $end
$var wire 1 # clk $end
$var wire 32 & pc_out [31:0] $end
$var wire 1 $ reset $end
$var wire 1 ' zero $end
$var wire 5 ( write_reg [4:0] $end
$var wire 32 ) write_back_data [31:0] $end
$var wire 32 * src_b [31:0] $end
$var wire 32 + sign_ext_imm [31:0] $end
$var wire 32 , result [31:0] $end
$var wire 1 - reg_write $end
$var wire 1 . reg_dst $end
$var wire 32 / read_data2 [31:0] $end
$var wire 32 0 read_data1 [31:0] $end
$var wire 32 1 pc_plus4 [31:0] $end
$var wire 32 2 pc_next [31:0] $end
$var wire 32 3 pc_branch [31:0] $end
$var wire 1 4 mem_write $end
$var wire 1 5 mem_to_reg $end
$var wire 32 6 mem_read_data [31:0] $end
$var wire 1 7 mem_read $end
$var wire 32 8 instruction [31:0] $end
$var wire 1 9 branch $end
$var wire 1 : alu_src $end
$var wire 4 ; alu_op [3:0] $end
$var reg 32 < pc [31:0] $end
$scope module ctrl $end
$var wire 6 = funct [5:0] $end
$var wire 6 > opcode [5:0] $end
$var reg 4 ? alu_op [3:0] $end
$var reg 1 : alu_src $end
$var reg 1 9 branch $end
$var reg 1 7 mem_read $end
$var reg 1 5 mem_to_reg $end
$var reg 1 4 mem_write $end
$var reg 1 . reg_dst $end
$var reg 1 - reg_write $end
$upscope $end
$scope module dmem $end
$var wire 1 # clk $end
$var wire 1 7 mem_read $end
$var wire 1 4 mem_write $end
$var wire 32 @ write_data [31:0] $end
$var wire 32 A read_data [31:0] $end
$var wire 32 B address [31:0] $end
$var integer 32 C i [31:0] $end
$upscope $end
$scope module imem $end
$var wire 32 D instruction [31:0] $end
$var wire 32 E pc [31:0] $end
$upscope $end
$scope module main_alu $end
$var wire 4 F alu_ctrl [3:0] $end
$var wire 32 G b [31:0] $end
$var wire 1 ' zero $end
$var wire 32 H a [31:0] $end
$var reg 32 I result [31:0] $end
$upscope $end
$scope module rf $end
$var wire 1 # clk $end
$var wire 5 J read_reg1 [4:0] $end
$var wire 5 K read_reg2 [4:0] $end
$var wire 1 - reg_write_en $end
$var wire 32 L write_data [31:0] $end
$var wire 5 M write_reg [4:0] $end
$var wire 32 N read_data2 [31:0] $end
$var wire 32 O read_data1 [31:0] $end
$var integer 32 P i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
b100000 P
b0 O
b0 N
b1 M
b1010 L
b1 K
b0 J
b1010 I
b0 H
b1010 G
b10 F
b0 E
b100000000000010000000000001010 D
b100000000 C
b1010 B
b0 A
b0 @
b10 ?
b1000 >
b1010 =
b0 <
b10 ;
1:
09
b100000000000010000000000001010 8
07
b0 6
05
04
b101100 3
b100 2
b100 1
b0 0
b0 /
0.
1-
b1010 ,
b1010 +
b1010 *
b1010 )
b1 (
0'
b0 &
b1010 %
1$
0#
b1010 "
b0 !
$end
#5
b1010 /
b1010 @
b1010 N
1#
#10
0#
0$
#15
b10100 )
b10100 L
b10100 "
b10100 %
b10100 ,
b10100 B
b10100 I
b0 /
b0 @
b0 N
b10 (
b10 M
1-
1:
b10 ;
b10 ?
b10 F
b10100 *
b10100 G
b10 K
b10100 =
b10100 +
b1000 2
b100000000000100000000000010100 8
b100000000000100000000000010100 D
b1011000 3
b1000 1
b100 !
b100 &
b100 <
b100 E
1#
#20
0#
#25
b11110 )
b11110 L
b11 (
b11 M
b11110 "
b11110 %
b11110 ,
b11110 B
b11110 I
b1010 0
b1010 H
b1010 O
1.
1-
0:
b10 ;
b10 ?
b10 F
b10100 *
b10100 G
b1 J
b100000 =
b0 >
b1100000100000 +
b10100 /
b10100 @
b10100 N
b1100 2
b1000100001100000100000 8
b1000100001100000100000 D
b110000010001100 3
b1100 1
b1000 !
b1000 &
b1000 <
b1000 E
1#
#30
0#
#35
b100 )
b100 L
b100 *
b100 G
b100 "
b100 %
b100 ,
b100 B
b100 I
b11110 /
b11110 @
b11110 N
b0 0
b0 H
b0 O
14
1:
0-
b10 ;
b10 ?
b10 F
0.
b11 K
b0 J
b100 =
b101011 >
b100 +
b10000 2
b10101100000000110000000000000100 8
b10101100000000110000000000000100 D
b100000 3
b10000 1
b1100 !
b1100 &
b1100 <
b1100 E
1#
#40
0#
#45
b11110 6
b11110 A
b11110 )
b11110 L
b0 /
b0 @
b0 N
b100 (
b100 M
17
1-
15
1:
04
b10 ;
b10 ?
b10 F
b100 K
b100011 >
b10100 2
b10001100000001000000000000000100 8
b10001100000001000000000000000100 D
b100100 3
b10100 1
b10000 !
b10000 &
b10000 <
b10000 E
1#
#50
0#
#55
1'
b0 )
b0 L
b0 6
b0 A
b0 "
b0 %
b0 ,
b0 B
b0 I
b1010 0
b1010 H
b1010 O
b1 (
b1 M
19
0-
0:
b110 ;
b110 ?
b110 F
05
07
b1010 *
b1010 G
b1 K
b1 J
b111111 =
b100 >
b11111111111111111111111111111111 +
b1010 /
b1010 @
b1010 N
b10100 2
b10000001000011111111111111111 8
b10000001000011111111111111111 D
b10100 3
b11000 1
b10100 !
b10100 &
b10100 <
b10100 E
1#
#60
0#
#65
1#
#70
0#
#75
1#
#80
0#
#85
1#
#90
0#
#95
1#
#100
0#
#105
1#
#110
0#
#115
1#
#120
0#
#125
1#
#130
0#
#135
1#
#140
0#
#145
1#
#150
0#
#155
1#
#160
0#
#165
1#
#170
0#
#175
1#
#180
0#
#185
1#
#190
0#
#195
1#
#200
0#
#205
1#
#210
0#
